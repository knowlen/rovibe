#!/usr/bin/env bash
set -euo pipefail

SCRIPT="assign"
log()  { echo "[$SCRIPT] $*"; }
err()  { echo "[$SCRIPT] ERROR: $*" >&2; exit 1; }

usage() {
  cat <<'EOF'
Usage: assign <agent> <project> [--role <role>] [--claude-md <path>]
       (args are order-independent, inferred by type)

Assigns an agent to a project:
  1. Sets agents group + read-only perms on project
  2. Creates symlink mirror of the project
  3. Creates .scratch/ workspace with write access
  4. Writes .claude/settings.local.json with deny rules
  5. Updates project .gitignore

Options:
  --role <role>        Assignment role (default: reviewer)
  --claude-md <path>   Copy a CLAUDE.md file into the mirror
EOF
  exit 1
}

# --- Parse arguments ---
AGENT_USER=""
PROJECT_DIR=""
CLAUDE_MD=""
ROLE="reviewer"
ORIG_ARGS=("$@")

operator_home=$(getent passwd "${SUDO_USER:-$USER}" | cut -d: -f6)

while [[ $# -gt 0 ]]; do
  case "$1" in
    --role)
      [[ $# -ge 2 ]] || err "--role requires a value"
      ROLE="$2"
      shift 2
      ;;
    --claude-md)
      [[ $# -ge 2 ]] || err "--claude-md requires a path argument"
      CLAUDE_MD="$2"
      shift 2
      ;;
    -h|--help)
      usage
      ;;
    *)
      # Classify bare args by type, not position.
      # Only ~/... is expanded; ~user/... is not supported (use absolute paths)
      if [[ "$1" == /* || "$1" == ~* || "$1" == ./* || "$1" == */* ]] \
         || [[ -d "$1" ]]; then
        [[ -z "$PROJECT_DIR" ]] || err "ambiguous: two paths provided"
        PROJECT_DIR="$1"
        [[ "$PROJECT_DIR" == ~/* || "$PROJECT_DIR" == "~" ]] && \
          PROJECT_DIR="${PROJECT_DIR/#\~/$operator_home}"
      elif id "$1" >/dev/null 2>&1 && id -nG "$1" 2>/dev/null | grep -qw agents; then
        [[ -z "$AGENT_USER" ]] || err "ambiguous: two agent users provided"
        AGENT_USER="$1"
      else
        err "cannot infer argument: $1"
      fi
      shift
      ;;
  esac
done

[[ -n "$AGENT_USER" ]] || err "Missing agent username"
[[ -n "$PROJECT_DIR" ]] || err "Missing project directory"
[[ -d "$PROJECT_DIR" ]] || err "Project directory does not exist: $PROJECT_DIR"
id "$AGENT_USER" >/dev/null 2>&1 || err "Agent user '$AGENT_USER' does not exist"

if [[ $EUID -ne 0 ]]; then
  exec sudo "$0" "${ORIG_ARGS[@]}"
fi

PROJECT_DIR=$(realpath "$PROJECT_DIR")
PROJECT_NAME=$(basename "$PROJECT_DIR")
MIRROR_DIR="/home/$AGENT_USER/mirrors/$PROJECT_NAME"
SCRATCH_DIR="$PROJECT_DIR/.scratch/reviews/$AGENT_USER"

# --- Step 1: Set group permissions on project ---
log "Setting agents group permissions on $PROJECT_DIR..."

# Set group ownership to agents
sudo chgrp -R agents "$PROJECT_DIR"

# Set group read + execute on dirs, group read on files, no group write
sudo chmod -R g+rX,g-w "$PROJECT_DIR"

# Detect and handle venvs, they need execute bits on binaries
while IFS= read -r -d '' venv_dir; do
  if [[ -d "$venv_dir/bin" ]]; then
    log "  Preserving execute bits in venv: $venv_dir/bin"
    sudo chmod -R g+rX "$venv_dir/bin"
  fi
done < <(find "$PROJECT_DIR" -maxdepth 2 -name "pyvenv.cfg" -printf '%h\0' 2>/dev/null || true)

# --- Step 2: Create symlink mirror ---
log "Creating symlink mirror at $MIRROR_DIR..."
sudo -u "$AGENT_USER" mkdir -p "$(dirname "$MIRROR_DIR")"

# Run sync-mirror, find it relative to this script or in PATH
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SYNC_MIRROR=""
if [[ -x "$SCRIPT_DIR/sync-mirror" ]]; then
  SYNC_MIRROR="$SCRIPT_DIR/sync-mirror"
elif command -v sync-mirror >/dev/null 2>&1; then
  SYNC_MIRROR="sync-mirror"
else
  err "sync-mirror not found"
fi

"$SYNC_MIRROR" "$PROJECT_DIR" "$MIRROR_DIR"
chown -h "$AGENT_USER":agents "$MIRROR_DIR"

# Record source path and role so list can display them
echo "$PROJECT_DIR" > "$MIRROR_DIR/.rovibe-source"
echo "$ROLE" > "$MIRROR_DIR/.rovibe-role"
chown "$AGENT_USER":agents "$MIRROR_DIR/.rovibe-source" "$MIRROR_DIR/.rovibe-role"

# --- Step 3: Create .scratch workspace ---
log "Creating .scratch workspace at $SCRATCH_DIR..."
sudo mkdir -p "$SCRATCH_DIR"
sudo chown "$AGENT_USER":agents "$SCRATCH_DIR"
sudo chmod 700 "$SCRATCH_DIR"

# Ensure parent .scratch/reviews dir exists with proper perms
sudo mkdir -p "$PROJECT_DIR/.scratch/reviews"
sudo chown root:agents "$PROJECT_DIR/.scratch" "$PROJECT_DIR/.scratch/reviews"
sudo chmod 3711 "$PROJECT_DIR/.scratch" "$PROJECT_DIR/.scratch/reviews"

# Migration: fix permissions on existing scratch dirs
if [[ -d "$PROJECT_DIR/.scratch/reviews" ]]; then
  for d in "$PROJECT_DIR/.scratch/reviews"/*/; do
    [[ -d "$d" ]] || continue
    user_name=$(basename "$d")
    if id "$user_name" >/dev/null 2>&1; then
      sudo chown "$user_name":agents "$d"
    fi
    sudo chmod 700 "$d"  # unconditional, locking stale dirs is safe
  done
  sudo chmod 3711 "$PROJECT_DIR/.scratch" \
                  "$PROJECT_DIR/.scratch/reviews"
fi

# Symlink agent's scratch dir into the mirror
local_scratch_link="$MIRROR_DIR/.scratch"
if [[ ! -L "$local_scratch_link" ]]; then
  sudo -u "$AGENT_USER" ln -s "$PROJECT_DIR/.scratch" "$local_scratch_link"
  log "  Symlinked .scratch into mirror"
fi

# --- Step 4: Write .claude/settings.local.json ---
log "Writing .claude/settings.local.json in mirror..."
CLAUDE_DIR="$MIRROR_DIR/.claude"
sudo -u "$AGENT_USER" mkdir -p "$CLAUDE_DIR"

sudo -u "$AGENT_USER" tee "$CLAUDE_DIR/settings.local.json" >/dev/null <<SETTINGS
{
  "permissions": {
    "allow": [
      "Bash(*)",
      "View",
      "Read"
    ],
    "deny": [
      "Bash(git add*)",
      "Bash(git commit*)",
      "Bash(git push*)",
      "Bash(git tag*)",
      "Bash(git merge*)",
      "Bash(git rebase*)",
      "Bash(git checkout*)",
      "Bash(git reset*)",
      "Bash(git stash*)",
      "Bash(git clean*)",
      "Bash(git remote*)",
      "Bash(sudo *)"
    ]
  }
}
SETTINGS

# --- Step 5: Copy CLAUDE.md if requested ---
if [[ -n "$CLAUDE_MD" ]]; then
  [[ -f "$CLAUDE_MD" ]] || err "CLAUDE.md file not found: $CLAUDE_MD"
  log "Copying CLAUDE.md into mirror..."
  sudo -u "$AGENT_USER" cp "$CLAUDE_MD" "$MIRROR_DIR/CLAUDE.md"
fi

# --- Step 6: Update project .gitignore ---
GITIGNORE="$PROJECT_DIR/.gitignore"

add_to_gitignore() {
  local entry="$1"
  if [[ -f "$GITIGNORE" ]]; then
    if ! grep -qxF "$entry" "$GITIGNORE"; then
      echo "$entry" | sudo tee -a "$GITIGNORE" >/dev/null
      log "  Added '$entry' to .gitignore"
    fi
  else
    echo "$entry" | sudo tee "$GITIGNORE" >/dev/null
    log "  Created .gitignore with '$entry'"
  fi
}

add_to_gitignore ".scratch/"

log "Agent '$AGENT_USER' assigned to '$PROJECT_NAME'."
log "Mirror: $MIRROR_DIR"
log "Scratch: $SCRATCH_DIR"
